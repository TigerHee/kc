import _ from 'lodash';
import webpack from 'webpack';
import ExtractTextPlugin from 'extract-text-webpack-plugin';
import HtmlWebpackPlugin from 'html-webpack-plugin';
import HtmlWebpackExcludeAssetsPlugin from 'html-webpack-exclude-assets-plugin';
import MD5 from 'crypto-js/md5';
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer';
import themeConifg from './theme.config';

const path = require('path');
const configs = require('./variable');
const sources = require('./sources');

const { isProd, analyzer, THEMES = '', site } = configs;
const msite = site || '';
const dev = process.env.NODE_ENV === 'development';
const IS_TEST_ENV = msite.indexOf('sit') === 0 && msite.indexOf('site') < 0;

const enableThemeNames = THEMES.split(',');
if (enableThemeNames.length === 0) {
  console.log('THEMES must be set');
  process.exit(1);
}

const extractCommon = new ExtractTextPlugin({
  filename: '[name].[contenthash:8].css',
  allChunks: true,
});

const genMd5 = (context, length) => {
  return MD5(context).toString().slice(0, length);
};

const cssModuleGetIndenName = (context, __, localName) => {
  const name = genMd5(context.context, 5);
  return `${localName}__${name}`;
};
const cssLoaderCfg = {
  loader: require.resolve('css-loader'),
  options: {
    importLoaders: 1,
    minimize: { minifyFontValues: false },
    sourceMap: true,
    modules: true,
    // localIdentName: '[local]___[hash:base64:5]',
    getLocalIdent: cssModuleGetIndenName,
  },
};

const postcssRtlPlugin = require('postcss-rtl')(
  require('./postcss-rlt-config'),
);

const postcssLoaderConfig = {
  loader: 'postcss-loader',
  options: {
    plugins: () => [postcssRtlPlugin],
  },
};

const lessLoaderConfig = (theme) => {
  return {
    loader: require.resolve('less-loader'),
    options: {
      modifyVars: themeConifg(theme),
    },
  };
};

/** themes extract */
const themesExtract = enableThemeNames.map((name) => {
  return new ExtractTextPlugin({
    filename: `style/${name}.css`,
    allChunks: false,
  });
});
const themeLoaders = enableThemeNames.map((name, index) => {
  const srcInclude = path.resolve(__dirname, 'src');
  return {
    test: new RegExp(`${name}\\.theme\\.less$`),
    include: srcInclude,
    use: themesExtract[index].extract({
      fallback: 'style-loader',
      use: [cssLoaderCfg, postcssLoaderConfig, lessLoaderConfig(name)],
    }),
  };
});

/** antd/kcui extract */
const NODE_MODULE_STYLES = ['antd', '@kc/ui'];
const pathNodeModules = path.resolve(__dirname, 'node_modules');
const stylesModuleExtract = NODE_MODULE_STYLES.map((module_name) => {
  const file_name = module_name.replace(/[/@]/g, '');
  return new ExtractTextPlugin({
    filename: `style/${file_name}.css`,
    allChunks: true,
  });
});
const stylesModuleTests = NODE_MODULE_STYLES.map((name) => {
  const testReg = new RegExp(`^${pathNodeModules}\\/${name}\\/.+\\.less$`);
  // const testReg = path.resolve(pathNodeModules, name);
  return testReg;
});

const ANTD_ICON_REGEXP = /node_modules\/antd\/es\/icon\/index\.js/;

export default (config) => {
  const _pushRules = [];
  let _rules = [...config.module.rules];
  _rules.forEach((rule) => {
    const isModuleLessLoader =
      rule.test &&
      rule.test instanceof RegExp &&
      rule.test.test('.less') &&
      rule.include &&
      rule.include instanceof RegExp &&
      rule.include.test('node_modules');

    const isSrcLessLoader =
      rule.test &&
      rule.test instanceof RegExp &&
      rule.test.test('.less') &&
      rule.exclude;

    const isCssLoader =
      rule.test && rule.test instanceof RegExp && rule.test.test('.css');

    if (isModuleLessLoader) {
      // copy to stylesModuleTests
      const newRule1 = _.cloneDeep(rule);
      const newRule2 = _.cloneDeep(rule);

      [newRule1, newRule2].forEach((itemRule, i) => {
        itemRule.test = stylesModuleTests[i];
        // itemRule.use[0] = stylesModuleExtract[i];
        delete itemRule.use[0];
        itemRule.use = stylesModuleExtract[i].extract({
          fallback: 'style-loader',
          use: itemRule.use.filter(Boolean),
        });
        // console.log(itemRule.use);
        // process.exit();
        itemRule.use[4].options.modifyVars['font-family'] =
          'Roboto, "Ubuntu", "Exo 2", Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft YaHei, "微软雅黑", Aril, sans-serif';
      });

      _pushRules.push(newRule1);
      _pushRules.push(newRule2);
      // exclude from node_modules rule
      rule.exclude = [rule.exclude, ...stylesModuleTests].filter(Boolean);
    } else if (isSrcLessLoader) {
      rule.exclude = [rule.exclude, /.*\.theme\.less$/, ...stylesModuleTests];
      if (isProd) {
        rule.use = extractCommon.extract({
          fallback: 'style-loader',
          use: [
            cssLoaderCfg,
            postcssLoaderConfig,
            lessLoaderConfig(enableThemeNames[0]),
          ],
        });
      } else {
        rule.use[1].options.getLocalIdent = cssModuleGetIndenName;
      }
    }

    // if (isCssLoader) {
    //   // rule.use[2].options.plugin.push(postcssRtlPlugin);
    //   console.log(rule.use[2].options.plugins()[2].toString());
    //   process.exit();
    // }

    const isJsLoader =
      rule.test &&
      rule.test instanceof RegExp &&
      rule.test.test('.js') &&
      rule.exclude &&
      rule.exclude instanceof RegExp &&
      rule.exclude.test('node_modules');
    if (isJsLoader) {
      const newRule = _.cloneDeep(rule);
      newRule.test = ANTD_ICON_REGEXP;
      delete newRule.exclude;

      _pushRules.push(newRule);
    }
  });

  _pushRules.push({
    test: /\.worker\.js$/,
    use: {
      loader: 'worker-loader',
      options: { inline: true, fallback: true },
    },
  });

  _rules = [..._rules, ...themeLoaders, ..._pushRules];

  config.module.rules = _rules;

  config.plugins.forEach((plugin, index) => {
    if (plugin instanceof ExtractTextPlugin) {
      config.plugins.splice(index, 1, extractCommon);
    }
    if (plugin instanceof HtmlWebpackPlugin) {
      config.plugins.splice(
        index,
        1,
        new HtmlWebpackPlugin({
          template: './index.ejs',
          filename: 'index.html',
          excludeAssets: [/\/style\/.*\.css$/, /theme\.js/],
          // favicon: path.resolve(__dirname, 'public/images/favicon.svg'),
          SENTRY_LAZY_LOAD:
            dev || IS_TEST_ENV
              ? 'https://assets-v2.kucoin.net/natasha/npm/sentry/7.52.1/sentry-loader.js'
              : 'https://assets.staticimg.com/natasha/npm/sentry/7.52.1/sentry-loader.js',
          RELATION_SRC:
            dev || IS_TEST_ENV
              ? `https://assets-v2.kucoin.net/web-domain-relation/boot.js?_v=${configs.name}-${configs.version}`
              : `https://assets.staticimg.com/web-domain-relation/boot.js?_v=${configs.name}-${configs.version}`,
          ANOMALY_SRC:
            dev || IS_TEST_ENV
              ? 'https://assets-v2.kucoin.net/common-statics/anomaly/anomaly.min.js'
              : 'https://assets3.staticimg.com/anomaly/anomaly.min.js',
          KCSENSORS_SRC:
            dev || IS_TEST_ENV
              ? 'https://assets-v2.kucoin.net/natasha/npm/@kc/sensors@1.3.0/umd/kcsensors.min.js'
              : 'https://assets.staticimg.com/natasha/npm/@kc/sensors@1.3.0/umd/kcsensors.min.js',
          ...sources,
        }),
      );
    }
  });

  // if (isProd) {
  //   config.plugins.push(
  //     new webpack.optimize.CommonsChunkPlugin({
  //       name: ['vendors', 'manifest'],
  //       filename: '[name].[chunkhash].js',
  //     }),
  //   );
  // }

  config.plugins.push(
    ...themesExtract,
    ...stylesModuleExtract,
    new HtmlWebpackExcludeAssetsPlugin(),
    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),
    new webpack.IgnorePlugin(/^intl\/locale-data\/jsonp\/.+\.js$/),
    new webpack.NormalModuleReplacementPlugin(
      ANTD_ICON_REGEXP,
      path.resolve(__dirname, 'src/components/Icon/index.js'),
    ),
  );
  config.externals = [
    {
      react: 'window.React',
      'react-dom': 'window.ReactDOM',
      'react-redux': 'window.ReactRedux',
      '@emotion/css': 'window.emotion',
      '@emotion/react': 'window.emotionReact',
      '@emotion/styled': 'window.emotionStyled',
      stylis: 'window.stylis',
    },
    function (_context, request, callback) {
      if (/^@kc\/mui$/.test(request)) {
        return callback(null, '$KcMui.components');
      }

      if (/^@kc\/mui\/lib/.test(request)) {
        return callback(
          null,
          request.replace(/^@kc\/mui\/lib/, '$KcMui').replace(/\//g, '.'),
        );
      }

      if (/^@kufox\/mui/.test(request)) {
        return callback(
          null,
          request.replace(/^@kufox\/mui/, '$KufoxMui').replace(/\//g, '.'),
        );
      }
      return callback();
    },
  ];

  if (isProd && analyzer) {
    config.plugins.push(new BundleAnalyzerPlugin());
  }

  return config;
};
