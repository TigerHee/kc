import 'dotenv/config'
import * as figmaExport from '@figma-export/core';
import fs from 'fs';
import path from 'path';
import { convertSvg2react } from './convert-svg-2-react';

const __dirname = path.dirname(new URL(import.meta.url).pathname);

const srcDir = path.join(__dirname, '../src');

function normalizeIconName(str: string) {
  return str.replace(/^(icons\/)?ic2_/, '')
    .replace(/_/g, '-')
    .trim().toLowerCase()
}

function convert2componentName(str: string) {
  return str.replace(/(^[a-z]|-[a-z])/gi, ($0, $1) => $0[$0.length-1]!.toUpperCase()) + 'Icon';
}

interface IconItem {
  svg: string;
  name: string;
}

/**
 * 获取 Figma 组件数据, 返回图标数组 IconItem[]
 * @param useLocal 如果为 true，则从本地文件读取组件数据，否则从 Figma API 获取
 * @returns 
 */
async function getComponentFromFigma(useLocal?: boolean) {
  if (useLocal) {
    const localComponents = fs.readFileSync(path.join(__dirname, 'components.json'), 'utf-8');
    return JSON.parse(localComponents) as IconItem[];
  }

  const resp = await figmaExport.components({
    fileId: process.env.FIGMA_FILE_ID!,
    ids: [
      process.env.FIGMA_ICON_CANVAS_NODE_ID!,
    ],
    token: process.env.FIGMA_API_KEY!,
    includeTypes: ['COMPONENT', 'INSTANCE'],
  });

  const canvas = resp[0];
  if (!canvas) {
    throw new Error('Canvas not found');
  }
  return canvas.components.map((component) => {
    const originName = component.name;
    // 跳过不符合命名格式的组件, 即认为非图标
    if (!originName || !/^(icons\/)?ic2/.test(originName) || !component.svg) {
      console.log(`Skipping component: ${originName}`);
      return null;
    }
    return {
      svg: component.svg,
      name: normalizeIconName(originName),
    }
  }).filter(Boolean) as IconItem[];
}

async function getComponents() {
  let components: IconItem[] = [];
  try {
    components = await getComponentFromFigma();
  } catch (error) {
    console.warn('Failed to fetch components from Figma:', error);
    console.warn('Falling back to local components.json');
    components = await getComponentFromFigma(true);
  }
  generateIconEntry(components);
  generateIcons(components);
  // 存档组件图标源文件
  fs.writeFileSync(path.join(__dirname, 'components.json'), JSON.stringify(components, null, 2));
  console.log('Components fetched:', components.length);
}

getComponents();

function generateIconEntry(icons: IconItem[]) {
  const iconNames = icons.map(icon => ({
    name: icon.name,
    componentName: convert2componentName(icon.name)
  }))
  .sort((a, b) => a.name.localeCompare(b.name));

  let listCode = `// This file is auto-generated by sync-icons script
// Do not edit manually.
export type { IIconProps } from './kc-icon';\n`;

  listCode += iconNames
    .map(icon => `import ${icon.componentName} from './icons/${icon.name}';`).join('\n') + '\n';
  
  listCode += '\nexport const iconMap = {\n' + iconNames.map(icon => `  ${icon.componentName}: ${icon.componentName},`).join('\n') + '\n};\n';

  fs.writeFileSync(
    path.join(srcDir, 'icon-map.tsx'),
    listCode
  );

  // 写入entry
  let code = `// This file is auto-generated by sync-icons script
// Do not edit manually.
export type { IIconProps } from './kc-icon';

`;
  code += iconNames
    .map(icon => `export { default as ${icon.componentName} } from './icons/${icon.name}';`).join('\n') + '\n'


  fs.writeFileSync(path.join(srcDir, 'index.tsx'), code);
}


function generateIcons(icons: IconItem[]) {
  const iconsDir = path.join(srcDir, 'icons');
  fs.rmSync(iconsDir, { recursive: true, force: true });
  fs.mkdirSync(iconsDir, { recursive: true });

  icons.forEach(async (icon) => {
    const filePath = path.join(iconsDir, `${icon.name}.tsx`);
    const componentCode = await convertSvg2react(icon.svg);
    fs.writeFileSync(filePath, componentCode);
  });
}
